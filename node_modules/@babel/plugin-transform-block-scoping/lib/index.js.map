{"version":3,"names":["declare","api","opts","assertVersion","throwIfClosureRequired","tdz","tdzEnabled","Error","name","visitor","traverse","visitors","merge","annexB33FunctionsVisitor","Loop","path","state","isForStatement","headPath","get","isForXStatement","needsBodyWrap","markNeedsBodyWrap","buildCodeFrameError","body","bodyScope","isBlockStatement","scope","bindings","getLoopBodyBindings","binding","capturedInClosure","getUsageInBody","captured","updatedBindingsUsages","Map","isBlockScoped","node","names","Object","keys","getBindingIdentifiers","headScope","hasOwnBinding","getOwnBinding","crawl","usages","hasConstantViolations","parent","hasBinding","hasGlobal","newName","generateUid","rename","push","set","varPath","wrapLoopBody","isVariableDeclaration","transformBlockScopedVariable","unwrapFunctionEnvironment","VariableDeclaration","ClassDeclaration","id","parentPath","isVarScope","noUids","conflictingFunctionsVisitor","Scope","kind","skip","dynamicTDZNames","validateUsage","bindingNames","isInLoop","isVarInLoopHead","length","decl","declarations","init","buildUndefinedNode","blockScope","varScope","getFunctionParent","getProgramParent","moveBindingTo","t","identifier","addHelper","isLetOrConst","isLoop","isFunctionParent","BLOCK_SCOPED_SYMBOL"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport { type PluginPass, types as t, traverse } from \"@babel/core\";\n\nimport {\n  getLoopBodyBindings,\n  getUsageInBody,\n  isVarInLoopHead,\n  wrapLoopBody,\n} from \"./loop\";\nimport { validateUsage } from \"./validation\";\nimport { annexB33FunctionsVisitor, isVarScope } from \"./annex-B_3_3\";\n\nexport interface Options {\n  tdz?: boolean;\n  throwIfClosureRequired?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const { throwIfClosureRequired = false, tdz: tdzEnabled = false } = opts;\n  if (typeof throwIfClosureRequired !== \"boolean\") {\n    throw new Error(`.throwIfClosureRequired must be a boolean, or undefined`);\n  }\n  if (typeof tdzEnabled !== \"boolean\") {\n    throw new Error(`.tdz must be a boolean, or undefined`);\n  }\n\n  return {\n    name: \"transform-block-scoping\",\n\n    visitor: traverse.visitors.merge<PluginPass>([\n      // TODO: Consider adding an option to control Annex B behavior.\n      annexB33FunctionsVisitor,\n      {\n        Loop(path: NodePath<t.Loop>, state) {\n          const isForStatement = path.isForStatement();\n          const headPath = isForStatement\n            ? path.get(\"init\")\n            : path.isForXStatement()\n            ? path.get(\"left\")\n            : null;\n\n          let needsBodyWrap = false;\n          const markNeedsBodyWrap = () => {\n            if (throwIfClosureRequired) {\n              throw path.buildCodeFrameError(\n                \"Compiling let/const in this block would add a closure \" +\n                  \"(throwIfClosureRequired).\",\n              );\n            }\n            needsBodyWrap = true;\n          };\n\n          const body = path.get(\"body\");\n          let bodyScope: Scope | null;\n          if (body.isBlockStatement()) {\n            bodyScope = body.scope;\n\n            const bindings = getLoopBodyBindings(path);\n            for (const binding of bindings) {\n              const { capturedInClosure } = getUsageInBody(binding, path);\n              if (capturedInClosure) markNeedsBodyWrap();\n            }\n          }\n\n          const captured: string[] = [];\n          const updatedBindingsUsages: Map<string, NodePath<t.Identifier>[]> =\n            new Map();\n\n          if (headPath && isBlockScoped(headPath.node)) {\n            const names = Object.keys(headPath.getBindingIdentifiers());\n            const headScope = headPath.scope;\n\n            for (let name of names) {\n              if (bodyScope?.hasOwnBinding(name)) continue; // shadowed\n\n              let binding = headScope.getOwnBinding(name);\n              if (!binding) {\n                headScope.crawl();\n                binding = headScope.getOwnBinding(name);\n              }\n              const { usages, capturedInClosure, hasConstantViolations } =\n                getUsageInBody(binding, path);\n\n              if (\n                headScope.parent.hasBinding(name) ||\n                headScope.parent.hasGlobal(name)\n              ) {\n                // If the binding is not captured, there is no need\n                // of adding it to the closure param. However, rename\n                // it if it shadows an outer binding, because the\n                // closure will be moved to an outer level.\n                const newName = headScope.generateUid(name);\n                headScope.rename(name, newName);\n                name = newName;\n              }\n\n              if (capturedInClosure) {\n                markNeedsBodyWrap();\n                captured.push(name);\n              }\n\n              if (isForStatement && hasConstantViolations) {\n                updatedBindingsUsages.set(name, usages);\n              }\n            }\n          }\n\n          if (needsBodyWrap) {\n            const varPath = wrapLoopBody(path, captured, updatedBindingsUsages);\n\n            if (headPath?.isVariableDeclaration<t.Node>()) {\n              // If we wrap the loop body, we transform the var\n              // declaration in the loop head now, to avoid\n              // invalid references that break other plugins:\n              //\n              //  for (let head of x) {\n              //    let i = head;\n              //    setTimeout(() => i);\n              //  }\n              //\n              // would become\n              //\n              //  function _loop() {\n              //    let i = head;\n              //    setTimeout(() => i);\n              //  }\n              //  for (let head of x) _loop();\n              //\n              // which references `head` in a scope where it's not visible.\n              transformBlockScopedVariable(headPath, state, tdzEnabled);\n            }\n\n            varPath.get(\"declarations.0.init\").unwrapFunctionEnvironment();\n          }\n        },\n\n        VariableDeclaration(path, state) {\n          transformBlockScopedVariable(path, state, tdzEnabled);\n        },\n\n        // Class declarations are block-scoped: if there is\n        // a class declaration in a nested block that conflicts\n        // with an outer block-scoped binding, rename it.\n        // TODO: Should this be moved to the classes plugin?\n        ClassDeclaration(path) {\n          const { id } = path.node;\n          if (!id) return;\n\n          const { scope } = path.parentPath;\n          if (\n            !isVarScope(scope) &&\n            scope.parent.hasBinding(id.name, { noUids: true })\n          ) {\n            path.scope.rename(id.name);\n          }\n        },\n      },\n    ]),\n  };\n});\n\nconst conflictingFunctionsVisitor: Visitor<{ names: string[] }> = {\n  Scope(path, { names }) {\n    for (const name of names) {\n      const binding = path.scope.getOwnBinding(name);\n      if (binding && binding.kind === \"hoisted\") {\n        path.scope.rename(name);\n      }\n    }\n  },\n  \"Expression|Declaration\"(path) {\n    path.skip();\n  },\n};\n\nfunction transformBlockScopedVariable(\n  path: NodePath<t.VariableDeclaration>,\n  state: PluginPass,\n  tdzEnabled: boolean,\n) {\n  if (!isBlockScoped(path.node)) return;\n\n  const dynamicTDZNames = validateUsage(path, state, tdzEnabled);\n\n  path.node.kind = \"var\";\n\n  const bindingNames = Object.keys(path.getBindingIdentifiers());\n  for (const name of bindingNames) {\n    const binding = path.scope.getOwnBinding(name);\n    if (!binding) continue;\n    binding.kind = \"var\";\n  }\n\n  if (\n    (isInLoop(path) && !isVarInLoopHead(path)) ||\n    dynamicTDZNames.length > 0\n  ) {\n    for (const decl of path.node.declarations) {\n      // We explicitly add `void 0` to cases like\n      //  for (;;) { let a; }\n      // to make sure that `a` doesn't keep the value from\n      // the previous iteration.\n      decl.init ??= path.scope.buildUndefinedNode();\n    }\n  }\n\n  const blockScope = path.scope;\n  const varScope =\n    blockScope.getFunctionParent() || blockScope.getProgramParent();\n\n  if (varScope !== blockScope) {\n    for (const name of bindingNames) {\n      let newName = name;\n      if (\n        // We pass `noUids` true because, if `name` was a generated\n        // UID, it has been used to declare the current variable in\n        // a nested scope and thus we don't need to assume that it\n        // may be declared (but not registered yet) in an upper one.\n        blockScope.parent.hasBinding(name, { noUids: true }) ||\n        blockScope.parent.hasGlobal(name)\n      ) {\n        newName = blockScope.generateUid(name);\n        blockScope.rename(name, newName);\n      }\n\n      blockScope.moveBindingTo(newName, varScope);\n    }\n  }\n\n  blockScope.path.traverse(conflictingFunctionsVisitor, {\n    names: bindingNames,\n  });\n\n  for (const name of dynamicTDZNames) {\n    path.scope.push({\n      id: t.identifier(name),\n      init: state.addHelper(\"temporalUndefined\"),\n    });\n  }\n}\n\nfunction isLetOrConst(kind: string): kind is \"let\" | \"const\" {\n  return kind === \"let\" || kind === \"const\";\n}\n\nfunction isInLoop(path: NodePath<t.Node>): boolean {\n  if (!path.parentPath) return false;\n  if (path.parentPath.isLoop()) return true;\n  if (path.parentPath.isFunctionParent()) return false;\n  return isInLoop(path.parentPath);\n}\n\nfunction isBlockSco